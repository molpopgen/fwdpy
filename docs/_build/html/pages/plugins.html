<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Overview &#8212; fwdpy 0.0.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Source code organization" href="code.html" />
    <link rel="prev" title="Estimating cumulative in simulations of quantitative traits." href="vareg.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="overview">
<h1>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This section assumes that you are familiar with running simulations using <em>fwdpy</em>.  If not, this section will make no sense at all.  This section is intended for those who want to build their own tools on top of <em>fwdpy</em>.  This document should also be read top to bottom, as later material builds on earlier stuff.</p>
</div>
<p>One of the more important features of <em>fwdpy</em> is that you may extend it by writing your own plugins.  By &#8220;plugin&#8221; I mean more than just some custom Python code to deal with output from the simulations.  Rather, a plugin means some combination of <a class="reference external" href="http://www.cython.org">Cython</a> or new C++11 code that adds a feature that you need for your research.</p>
<p>Most plugins will only need to be written using <a class="reference external" href="http://www.cython.org">Cython</a>.  I will take care to mention when a plugin would require new C++11 code.  The goal is to make the latter case a very rare occurrence.  As a programming language, <a class="reference external" href="http://www.cython.org">Cython</a> may be viewed as &#8220;Python with types&#8221;.  In other words, consider the following Python funtion to add two numbers:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_em_up</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
   <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Using <a class="reference external" href="http://www.cython.org">Cython</a>, such a function could take one of a few forms:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c">#As a Python function, but with the argument types specified:</span>
<span class="k">def</span> <span class="nf">add_em_up</span><span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span><span class="n">double</span> <span class="n">y</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>

<span class="c">#As a function that is only callable as a C/C++ function</span>
<span class="c">#elsewhere within a Cython module:</span>
<span class="k">cdef</span> <span class="kt">double</span> <span class="nf">add_em_up_C_CPP</span><span class="p">(</span><span class="n">double</span> <span class="n">x</span><span class="p">,</span><span class="n">double</span> <span class="n">y</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>

<span class="c">#As a function that can be called both from C/C++ and from Python:</span>
<span class="k">cpdef</span> <span class="kt">double</span> <span class="nf">add_em_up_C_CPP_PY</span><span class="p">(</span><span class="n">double</span> <span class="n">y</span><span class="p">,</span><span class="n">double</span> <span class="n">y</span><span class="p">):</span>
   <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span>
</pre></div>
</div>
<p>A full overview of coding in <a class="reference external" href="http://www.cython.org">Cython</a> is beyond the scope of this manual&#8211;please see their documentation for more details.  A quick overview is found <a class="reference external" href="http://docs.cython.org/src/reference/language_basics.html">here</a>.</p>
<p>For most purposes, a plugin will consist of:</p>
<ul class="simple">
<li>A &#8220;cdef&#8221; function that works on some of the underlying C++ types</li>
<li>A &#8220;def&#8221; function that will take objects from <em>fwdpy</em> and apply the &#8220;cdef&#8221; function to those objects.</li>
</ul>
<p>The former is the &#8220;back end&#8221; of your plugin, and the latter is the Python interface that makes it useful.</p>
<div class="section" id="glossary">
<h2>Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<p>In one sense <a class="reference external" href="http://www.cython.org">Cython</a> is a &#8220;dialect&#8221; of Python, in that it augments Python with C and C++ data types. You may need to familiarize yourself with the basics:</p>
<ul class="simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/C_data_types">C</a> data types defined</li>
<li>A &#8220;return value&#8221; is the name of a type that is returned by a function.  void = noting.  Otherwise, something is returned.</li>
<li>&#8220;const&#8221; is a keyword meaning &#8220;cannot be modified&#8221;, or constant. C++ code attempting to modify a const variable will fail to compile.</li>
<li>&#8220;class&#8221; is a complex type.  These are often composed of the fundamental types, such as <a class="reference external" href="https://en.wikipedia.org/wiki/C_data_types">C</a> types.  Alternately, they may be entirely new types defined by a library, such as those descbied below.</li>
<li>&#8220;object&#8221; is an instance of type or class. In the following example, vector[int] is a class type, and x is an object whose type is vector[int]:</li>
</ul>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="nn">libcpp.vector</span> <span class="k">cimport</span> <span class="n">vector</span>
<span class="k">cdef</span> <span class="kt">vector</span>[<span class="kt">int</span>] <span class="nf">x</span>
</pre></div>
</div>
<p>PS, you just learned how to bring C++&#8217;s vector class into scope using <a class="reference external" href="http://www.cython.org">Cython</a>.</p>
</div>
<div class="section" id="file-extensions">
<h2>File extensions<a class="headerlink" href="#file-extensions" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference external" href="http://www.cython.org">Cython</a> code for a plugin will go into a &#8221;.pyx&#8221; file.  This is known as a &#8220;<a class="reference external" href="https://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/">Pyrex</a>&#8221; file type, and <a class="reference external" href="https://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/">Pyrex</a> is the precuror to <a class="reference external" href="http://www.cython.org">Cython</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You will want to make sure that your text editor supports the .pyx and .pxd file extensions.  <a class="reference external" href="http://www.cython.org">Cython</a> provides a <a class="reference external" href="https://github.com/cython/cython/blob/master/Tools/cython-mode.el">plugin</a> for Emacs.  Casual Google searches find several options for the vi/vim family of editors.  I have no idea what, if anything, is avaiable for OS X editors like BBEdit, TextWrangler, or Xcode.  If you use them, you need to sort that out on your own.  I use Emacs and vim because they work the same way on all systems and I can edit files remotely via SSH. For vim/neovim users, <a class="reference external" href="https://github.com/Valloric/YouCompleteMe#python-semantic-completion">YouCompleteMe</a> (with code completion enabled) is a truely spetacular way to edit <a class="reference external" href="http://www.cython.org">Cython</a> code&#8211;the code completion is quite cool.  However, you are on your own installing it, as it is a bit tricky to get up and running.</p>
</div>
<p>For plugins that require extra C++ code, header files should have the .h or .hpp extension, and source files should have the .cc extension.  You should avoid .cpp for the following reason: <a class="reference external" href="http://www.cython.org">Cython</a> will process a pyx file into a .cpp file.  This behavior can have side-effects.  IF you have <a class="reference external" href="http://www.cython.org">Cython</a> code in foo.pyx and some additional C++ code in foo.cpp, the latter file will be over-written when <a class="reference external" href="http://www.cython.org">Cython</a> compiles foo.pyx into a C++ file (which will be called foo.cpp)!  Use .cc to avoid that.</p>
</div>
<div class="section" id="compiling-a-cython-only-plugin">
<h2>Compiling a Cython-only plugin<a class="headerlink" href="#compiling-a-cython-only-plugin" title="Permalink to this headline">¶</a></h2>
<p>This section describes the &#8220;easy way&#8221; to compile a plugin.  This method only applies to plugins consisting only of <a class="reference external" href="http://www.cython.org">Cython</a> code (.pyx files).</p>
<p>I will assume that your module will be called &#8220;foo&#8221;.</p>
<p>You will need three files:</p>
<ul class="simple">
<li>foo.pyx contains your <a class="reference external" href="http://www.cython.org">Cython</a> code</li>
<li>foo.pyxbuild contains extra info to tell the system that this plugin the C++11 language</li>
<li>compile_foo.py is a Python script that will handle the compilation.</li>
</ul>
<p>The contents of foo.pyx contain whatever code you need to write for your module.</p>
<p>foo.pyxbld contains the information needed to compile the plugin on the fly.  fwdpy is capable of generating these files for you:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">fwdpy</span> <span class="kn">as</span> <span class="nn">fp</span>
<span class="c1">#Generate foo.pyxbld</span>
<span class="n">fp</span><span class="o">.</span><span class="n">make_pyxbld</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you are using the clang compiler, be prepared for a metric ton(ne) of compiler warnings.  These warnings are from the Cython-generated C++ code.</p>
</div>
<p>Finally, compile_foo.py contains <em>at least</em> the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pyximport</span>
<span class="n">pyximport</span><span class="o">.</span><span class="n">install</span><span class="p">()</span>
<span class="c1">#This import command will process foo.pyx,</span>
<span class="c1">#generate a C++ source file based on it,</span>
<span class="c1">#and compile it!  This only needs to happen once,</span>
<span class="c1">#and recompilation will only happen if you make</span>
<span class="c1">#changes to foo.pyx</span>
<span class="kn">import</span> <span class="nn">foo</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Your Python source file can do more than just compile the module.  It could run simuations and apply your custom plugin code.  Or, you could just have one script that imports a lot of modules to compile them.</p>
</div>
</div>
<div class="section" id="compiling-a-plugin-that-contains-extra-c-code">
<h2>Compiling a plugin that contains extra C++ code<a class="headerlink" href="#compiling-a-plugin-that-contains-extra-c-code" title="Permalink to this headline">¶</a></h2>
<p><strong>TBD</strong></p>
</div>
<div class="section" id="the-c-types-used-in-fwdpy">
<h2>The C++ types used in <em>fwdpy</em><a class="headerlink" href="#the-c-types-used-in-fwdpy" title="Permalink to this headline">¶</a></h2>
<p><em>fwdpy</em> is implemented in terms of the following:</p>
<ol class="arabic simple">
<li><a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a>, which is a C++11 library for forward simulation.  It is the &#8220;guts&#8221; of fwdpy and does most of the harder work that needs to be fast.</li>
<li><a class="reference external" href="http://gnu.org/software/gsl">GSL</a>, which is a C library for numeric computation.  <em>fwdpy</em> and <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a> use <a class="reference external" href="http://gnu.org/software/gsl">GSL</a> for random number generation, fast lookup tables, etc.</li>
<li><a class="reference external" href="http://www.cython.org">Cython</a> is the glue between <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a>, <a class="reference external" href="http://gnu.org/software/gsl">GSL</a>, and Python.</li>
<li><a class="reference external" href="https://pypi.python.org/pypi/CythonGSL">cythonGSL</a> exposes the <a class="reference external" href="http://gnu.org/software/gsl">GSL</a> to <a class="reference external" href="http://www.cython.org">Cython</a> so that we don&#8217;t have to reinvent all of those wrappers.</li>
</ol>
<p>In order to write a plugin, you need all of the above installed on your system.</p>
<p>Let&#8217;s go through the <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a> types used in <em>fwdpy</em>, and how to manipulate them in <a class="reference external" href="http://www.cython.org">Cython</a>.</p>
<p>I will give the names of header files where these types are defined.  For <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a> types, you may get all the gory details about them from that library&#8217;s <a class="reference external" href="http://molpopgen.github.io/fwdpp/doc/html/index.html">manual</a>.</p>
<p>The next sections go through the relevant C++ types in a &#8220;biological&#8221; order: mutation, mutation container, gamete, gamete container, diploid, etc.  Finally, we discuss the population objects that hold all of these together.</p>
<div class="section" id="mutation-types">
<h3>Mutation types<a class="headerlink" href="#mutation-types" title="Permalink to this headline">¶</a></h3>
<div class="section" id="popgenmut">
<h4>popgenmut<a class="headerlink" href="#popgenmut" title="Permalink to this headline">¶</a></h4>
<p>This is the C++ name of the type of mutation used in <em>fwdpy</em>.  It is a mutation type with the following data members:</p>
<ol class="arabic simple">
<li><strong>pos</strong>: the mutation position.  This is a double-precision floating point number.</li>
<li><strong>s</strong>: the &#8220;selection coefficient&#8221; or &#8220;effect size&#8221;. This is a double-precision floating point number.</li>
<li><strong>h</strong>: The dominance term. This is a double-precision floating point number.</li>
<li><strong>neutral</strong>: A boolean (C++ type bool) that flags the mutation as &#8220;neutral&#8221; or &#8220;selected&#8221; (true and false, respectively).</li>
<li><strong>g</strong>: an unsigned (non-negative) 32-bit integer recording the generation when the mutation first appeared.</li>
<li><strong>label</strong>: this is a 16 bit unsigned integer.  In practice, not much is done with it, but you can use it for adding 16 bits of extra info to a mutation type.  It was given a name in order to make use of wasted storage in the C++ type.</li>
</ol>
<p>This type is defined in the <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a> header file fwdpp/sugar/popgenmut.hpp.  It is exposed to <a class="reference external" href="http://www.cython.org">Cython</a> via fwdpy/fwdpp.pxd.</p>
<p>Let&#8217;s show how to access these data members in <a class="reference external" href="http://www.cython.org">Cython</a>.  First, we will consider the case of simply assigning each data member to another variable.  This is a pointless example, but it serves to illustrate some key concepts:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c">#We must bring popgenmut into scope</span>
<span class="k">from</span> <span class="nn">fwdpy.fwdpp</span> <span class="k">cimport</span> <span class="n">popgenmut</span>

<span class="c">#The &quot;void&quot; return type mean that the function does not return a value</span>
<span class="k">cdef</span> <span class="kt">void</span> <span class="nf">do_something</span><span class="p">(</span><span class="n">const</span> <span class="n">popgenmut</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">s</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">s</span>
    <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">h</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">h</span>
    <span class="k">cdef</span> <span class="kt">double</span> <span class="nf">pos</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">pos</span>
    <span class="k">cdef</span> <span class="kt">bint</span> <span class="nf">neutral</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">neutral</span>
</pre></div>
</div>
<p>Key points:</p>
<ul class="simple">
<li>&#8220;nogil&#8221;: this function does not act on any Python objects. As a rule of thumb, declare such functions as nogil so that they may be used in parallel programming. See <a class="reference external" href="http://www.cython.org">Cython</a> docs for more info.</li>
<li>&#8220;&amp;&#8221;: this means that our function takes a &#8220;reference&#8221; to a popgenmut.  Withouth the &#8220;&amp;&#8221;, &#8216;m&#8217; would be copied and then passed to do_something.  That copy is unnecessary and expensive, and therefore incorrect!</li>
<li>&#8220;const&#8221;: our function takes a const reference to a poppgenmut.  The const means that we cannot try to modify any of the data members in m.  Attempting to do so will fail to compile.</li>
</ul>
<p>We can write non-const functions, too.  But please be aware that this gives you the ability to manipulate the population data directly.  In other words, doing the wrong thing can result in undefined behavior and crashes.</p>
<p>Here is a non-const function to change the selection coefficient:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="nn">fwdpy.fwdpp</span> <span class="k">cimport</span> <span class="n">popgenmut</span>

<span class="k">cdef</span> <span class="kt">void</span> <span class="nf">change_s</span><span class="p">(</span><span class="n">popgenmut</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="n">connst</span> <span class="n">double</span> <span class="n">news</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="c">#We CAN modify m, because it is not const!</span>
    <span class="n">m</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">news</span>
</pre></div>
</div>
<p>And, here is why the &#8220;&amp;&#8221; matters:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="nn">fwdpy.fwdpp</span> <span class="k">cimport</span> <span class="n">popgenmut</span>

<span class="k">cdef</span> <span class="kt">void</span> <span class="nf">try_2_change_s</span><span class="p">(</span><span class="n">popgenmut</span> <span class="n">m</span><span class="p">,</span> <span class="n">const</span> <span class="n">double</span> <span class="n">news</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="c">#m has been passed in as a COPY, and not as a REFERENCE.</span>
    <span class="c">#Thus, the COPY has its selection coefficent changed,</span>
    <span class="c">#which will not have any effect on the population being</span>
    <span class="c">#simulated</span>
    <span class="n">m</span><span class="o">.</span><span class="n">s</span><span class="o">=</span><span class="n">news</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="mutation-containers-and-mutation-counts">
<h3>Mutation containers and mutation counts.<a class="headerlink" href="#mutation-containers-and-mutation-counts" title="Permalink to this headline">¶</a></h3>
<p>Defined in the fwdpy header &#8220;types.hpp&#8221;.</p>
<p>A population consists of a C++ vector of mutations.  Functionally, this is very similar to the &#8220;list&#8221; type in Python.</p>
<p>In <em>fwdpy</em>, a vector of mutations goes by the name mcont_t (mutation container type), which refers to a <strong>vector</strong> of <strong>popgenmut</strong> objects.</p>
<p>A population consists of a second container containing the number of times each mutation exists in the population.  This is a C++ vector of unsigned (e.g., non-negative) integers, and <em>fwdpy</em> uses the alias ucont_t for this type.</p>
<p>Key points:</p>
<ul class="simple">
<li>These two vectors are the same length.</li>
<li>The order of elements in each vector is the same, in the sense that the number of occurrences of the i-th mutation is found in the i-th position of the counts container.</li>
<li>In these vectors, elements are completely unsorted with respect to age, effect size, position, or anything.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A mutation container contains both segregating mutations <em>and</em> extinct mutations.  <strong>It is therefore important to skip over extinct mutations when calculating things!!!  You may also want to check for, and skip, fixations</strong>. There are a few reasons for this, efficiency being one of them; <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a> will &#8220;recycle&#8221; the extinct mutations to create new mutations.  Further, the containers may or may not contain fixations.  Most &#8220;standard&#8221; population genetic simulations will remove both neutral and selected fixations from these containers.  Simulations of models such as Gaussian stabilizing selection around an optimum trait value (currently) retain fixations.  The reason for this difference is that fixations in the standard model do not contribute to differences in relative fitness.  But, in the Gaussian stabilizing selection models, they still contribute to mean trait value.  Future versions of <em>fwdpy</em> may change the behavior of Gaussian selection models, removing fixations and simply keeping track of the sum of fixed effect sizes (at least for the case of additive models).</p>
</div>
<p>Fixations are stored in an mcont_t and the corresponding fixation_times are stored in a ucont_t.</p>
<p>Simulations also use a lookup table to quickly ask if a new mutation position already exists in the population or not.  This lookup table vastly speeds up the implementation of infinitely-many sites mutation schemes.  The C++11 type is:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="n">KTfwd</span><span class="o">::</span><span class="n">equal_eps</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The alias for this type provided by <em>fwdpy</em> is lookup_t.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is very unlikely that you will ever need to access/manipulate a lookup_t directly.  If you ever have the desire to add/remove from one, think carefully, and then think again.  A lookup_t is modified when adding/removing mutations from the population.  As a rule, this should not be done manually.  Rather, you should use use functions like <a class="reference internal" href="../index.html#fwdpy.fwdpy.add_mutation" title="fwdpy.fwdpy.add_mutation"><code class="xref py py-func docutils literal"><span class="pre">fwdpy.fwdpy.add_mutation()</span></code></a>.</p>
</div>
<p>We will save examples of processing these objects until the section on dealing with whole-population objects.</p>
</div>
<div class="section" id="gametes-and-gamete-containers">
<h3>Gametes and gamete containers<a class="headerlink" href="#gametes-and-gamete-containers" title="Permalink to this headline">¶</a></h3>
<p>Defined in the fwdpy header &#8220;types.hpp&#8221;, which refers to the <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a> type defined in fwdpp/forward_types.hpp.</p>
<p>A gamete is a simple object.  It contains the following data members:</p>
<ul class="simple">
<li><strong>n</strong> is an unsigned integer representing how many diploids are referring to this exact copy of this gamete.</li>
<li><strong>mutations</strong> is a C++ vector of unsigned 64-bit integers.  Each integer is an index referring to a location in the mutation container.  This container is for neutral mutations only.  In other words, the &#8220;neutral&#8221; value of each mutation must be &#8220;true&#8221;.</li>
<li><strong>smutations</strong> is the analog of mutations, but for &#8220;selected&#8221; mutations (e.g., those affecting fitness/trait values).  The value of each mutation referred to has &#8220;neutral&#8221; set to &#8220;false&#8221;.</li>
</ul>
<p>In C/C++, the unsigned 64-bit integer type is size_t.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>n</strong> is <em>not</em> equivalent to how many times a gamete exists in the population.  <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a> makes no attempt to represent each identical gamete once-and-only-once.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The integers in <strong>mutations</strong> and <strong>smutations</strong> are <em>sorted with respect to mutation position, in ascending order</em>.  Behind the scenes, <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a> makes sure that this sorting order is maintained.  It allows cool things like log-time lookup of mutations based on position, etc.</p>
</div>
<p><em>fwdpy</em> exposes the name gamete_t to refer to this type:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="nn">fwdpy.fwdpy</span> <span class="k">cimport</span> <span class="n">gamete_t</span>
</pre></div>
</div>
<p>Gametes are stored in a C++ vector.  The alias for this type is gcont_t:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="nn">fwdpy.fwdpy</span> <span class="k">cimport</span> <span class="n">gcont_t</span>
</pre></div>
</div>
<p>Again, we will save examples of processing these objects until the section on dealing with whole-population objects.</p>
</div>
<div class="section" id="diploids">
<h3>Diploids<a class="headerlink" href="#diploids" title="Permalink to this headline">¶</a></h3>
<p>Defined in the <em>fdwpy</em> header &#8220;types.hpp&#8221;.  In <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a> lingo, this is a <a class="reference external" href="http://molpopgen.github.io/fwdpp/doc/html/d2/dcd/md_md_customdip.html">custom</a> diploid.</p>
<p>A diploid is a very simple C++ type with the following data members:</p>
<ul class="simple">
<li><strong>first</strong> is a size_t (unsigned 64-bit integer) with is the location in a gamete container of the first gamete</li>
<li><strong>second</strong> is a size_t (unsigned 64-bit integer) with is the location in a gamete container of the second gamete</li>
<li><strong>g</strong> is a double-precision floating point value representing a &#8220;genetic&#8221; value</li>
<li><strong>e</strong> is a double-precision floating point value representing a &#8220;non-genetic&#8221; value.  For example, random noise applied to a trait</li>
<li><strong>w</strong> is a double-precision floating point value representing fitness.</li>
</ul>
<p>We have the following types:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c">#This is a diploid</span>
<span class="k">from</span> <span class="nn">fwdpy.fwdpy</span> <span class="k">cimport</span> <span class="n">diplod_t</span>
<span class="c">#This is a C++ vector of diploids</span>
<span class="k">from</span> <span class="nn">fwdpy.fwdpy</span> <span class="k">cimport</span> <span class="n">dipvector_t</span>
</pre></div>
</div>
</div>
<div class="section" id="population-types">
<h3>Population types<a class="headerlink" href="#population-types" title="Permalink to this headline">¶</a></h3>
<p>This is where the action is.  A population is a C++ object containing the above data types.</p>
<div class="section" id="singlepop-t">
<h4>singlepop_t<a class="headerlink" href="#singlepop-t" title="Permalink to this headline">¶</a></h4>
<p>Defined in <em>fwdpy</em> header &#8220;types.hpp&#8221;.  This class inherits from the <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a> tempate type singlepop (fwdpp/sugar/singlepop.hpp).</p>
<p>This type is used to model the following situation:</p>
<ul class="simple">
<li>A single deme</li>
<li>A contiguous genomic region. Mutation rates, recombination rates, etc., may vary along this region via the use of <a class="reference internal" href="../index.html#fwdpy.fwdpy.Region" title="fwdpy.fwdpy.Region"><code class="xref py py-class docutils literal"><span class="pre">fwdpy.fwdpy.Region</span></code></a> objects.</li>
</ul>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="nn">fwdpy.fwdpy</span> <span class="k">cimport</span> <span class="n">singlepop_t</span>
</pre></div>
</div>
<p>It has the following data members:</p>
<ul class="simple">
<li><strong>generation</strong>, an unsigned 32-bit integer representing the current generation. 0 is the starting value.</li>
<li><strong>N</strong>, an unsigned 32-bit integer representing current population size</li>
<li><strong>mutations</strong>, an mcont_t containing the mutations</li>
<li><strong>mcounts</strong>, a ucont_t containg the number of occurrences of each mutation</li>
<li><strong>mut_lookup</strong>, a lookup_t (see above).</li>
<li><strong>fixations</strong>, an mcont_t containing fixations</li>
<li><strong>fixation_times</strong>, a cont_t containing the fixation times.</li>
<li><strong>gametes</strong>, a gcont_t containing the gametes</li>
<li><strong>diploids</strong>, a dipvector_t containing the diploids.</li>
</ul>
<div class="section" id="singlepop-t-and-python">
<h5>singlepop_t and Python<a class="headerlink" href="#singlepop-t-and-python" title="Permalink to this headline">¶</a></h5>
<p>&#8220;Under the hood&#8221;, a <a class="reference internal" href="../index.html#fwdpy.fwdpy.Spop" title="fwdpy.fwdpy.Spop"><code class="xref py py-class docutils literal"><span class="pre">fwdpy.fwdpy.Spop</span></code></a> is a wrapper around a singlepop_t.  This type is a &#8220;Cython extension type&#8221;, and is a fundamental type in <em>fwdpy</em>.  One uses containers of these types in the form of <a class="reference internal" href="../index.html#fwdpy.fwdpy.SpopVec" title="fwdpy.fwdpy.SpopVec"><code class="xref py py-class docutils literal"><span class="pre">fwdpy.fwdpy.SpopVec</span></code></a>.</p>
<p>We have to get a gory detail out of the way.  A <a class="reference internal" href="../index.html#fwdpy.fwdpy.Spop" title="fwdpy.fwdpy.Spop"><code class="xref py py-class docutils literal"><span class="pre">fwdpy.fwdpy.Spop</span></code></a> contains a C++11 &#8220;shared pointer&#8221; to a singlepop_t.  We&#8217;ll see the implications of this in the recipes below.</p>
</div>
<div class="section" id="recipes">
<h5>Recipes<a class="headerlink" href="#recipes" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">These recipes will start simply and quickly get advanced.  They&#8217;ll show you what stuff from <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a> is exposed to Cython and you&#8217;ll also see some that <em>fwdpy</em> defines that may be of use for your own plugins.</p>
</div>
<p>First things first: how to go from a <a class="reference internal" href="../index.html#fwdpy.fwdpy.Spop" title="fwdpy.fwdpy.Spop"><code class="xref py py-class docutils literal"><span class="pre">fwdpy.fwdpy.Spop</span></code></a> to a singlepopt_t in a plugin:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="nn">fwdpy.fwdpy</span> <span class="k">cimport</span> <span class="n">singlepop_t</span>

<span class="c">#A very boring plugin indeed!</span>
<span class="k">cdef</span> <span class="kt">void</span> <span class="nf">my_plugin_function</span><span class="p">(</span><span class="n">const</span> <span class="n">singlepop_t</span> <span class="o">*</span> <span class="n">pop</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="c">#This will be the function that your plugin exposes</span>
<span class="c">#to Python:</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">Spop</span> <span class="n">p</span><span class="p">):</span>
   <span class="c">#p is your Spop, pop is the shared pointer,</span>
   <span class="c">#and pop.get() returns the raw pointer</span>
   <span class="c">#to the singlepop_t</span>
   <span class="n">my_plugin_function</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">pop</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
</pre></div>
</div>
<p>Count the number of segregating mutations in the entire population:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kt">unsigned</span> <span class="nf">count_muts</span><span class="p">(</span><span class="n">const</span> <span class="n">singlepop_t</span> <span class="o">*</span> <span class="n">pop</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">cdef</span> <span class="kt">size_t</span> <span class="nf">i</span><span class="o">=</span><span class="mf">0</span>
    <span class="k">cdef</span> <span class="kt">size_t</span> <span class="nf">n</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">mcounts</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="nf">twoN</span> <span class="o">=</span> <span class="mf">2</span><span class="o">*</span><span class="n">pop</span><span class="o">.</span><span class="n">popsize</span><span class="p">()</span> <span class="c">#This is a member function that returns pop.N</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="nf">extant</span><span class="o">=</span><span class="mf">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c">#Check that mutation is not extinct and not fixed</span>
        <span class="k">if</span> <span class="n">pop</span><span class="o">.</span><span class="n">mcounts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0</span> <span class="ow">and</span> <span class="n">pop</span><span class="o">.</span><span class="n">mcounts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">twoN</span><span class="p">:</span>
             <span class="n">extant</span><span class="o">+=</span><span class="mf">1</span>
    <span class="c">#return our count</span>
    <span class="k">return</span> <span class="n">extant</span>
</pre></div>
</div>
<p>Count the number of segregating <em>neutral</em> mutations in the entire population:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kt">unsigned</span> <span class="nf">count_neutral_muts</span><span class="p">(</span><span class="n">const</span> <span class="n">singlepop_t</span> <span class="o">*</span> <span class="n">pop</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">cdef</span> <span class="kt">size_t</span> <span class="nf">i</span><span class="o">=</span><span class="mf">0</span>
    <span class="k">cdef</span> <span class="kt">size_t</span> <span class="nf">n</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">mcounts</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="nf">twoN</span> <span class="o">=</span> <span class="mf">2</span><span class="o">*</span><span class="n">pop</span><span class="o">.</span><span class="n">popsize</span><span class="p">()</span> <span class="c">#This is a member function that returns pop.N</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="nf">extant</span><span class="o">=</span><span class="mf">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c">#Check that mutation is not extinct and not fixed and is neutral</span>
        <span class="k">if</span> <span class="n">pop</span><span class="o">.</span><span class="n">mcounts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0</span> <span class="ow">and</span> <span class="n">pop</span><span class="o">.</span><span class="n">mcounts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">twoN</span> <span class="ow">and</span> <span class="n">pop</span><span class="o">.</span><span class="n">mutations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">neutral</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
             <span class="n">extant</span><span class="o">+=</span><span class="mf">1</span>
    <span class="c">#return our count</span>
    <span class="k">return</span> <span class="n">extant</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Counting the number of <em>selected</em> mutations would be the same, but checking for &#8220;neutral is False&#8221;.</p>
</div>
<p>Count the number of neutral and selected mutations per gamete, return a list of tuples to Python with that info.</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="nn">fwdpy.fdwpy</span> <span class="k">cimport</span> <span class="n">singlepop_t</span>
<span class="c">#The next 2 cimports are from Cython&#39;s wrappers for the C++ standard library.</span>
<span class="k">from</span> <span class="nn">libcpp.vector</span> <span class="k">cimport</span> <span class="n">vector</span>
<span class="k">from</span> <span class="nn">libccp.utility</span> <span class="k">cimport</span> <span class="n">pair</span>

<span class="c">#KEY: a C++ pair auto-converts to a Python tuple.  A C++ vector auto converts to a list.</span>
<span class="c">#So guess what a vector of pairs converts to?</span>

<span class="c">#(A list of tuples)</span>

<span class="c">#This is a helper function.  It will count the number of segregating mutations</span>
<span class="c">#in each gamete.</span>
<span class="k">cdef</span> <span class="kt">int</span> <span class="nf">count_mutations</span><span class="p">(</span><span class="n">const</span> <span class="n">vector</span><span class="p">[</span><span class="n">size_t</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">keys</span><span class="p">,</span><span class="n">const</span> <span class="n">ucont_t</span> <span class="o">&amp;</span> <span class="n">mcounts</span><span class="p">,</span><span class="n">const</span> <span class="nb">unsigned</span> <span class="n">twoN</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">cdef</span> <span class="kt">size_t</span> <span class="nf">i</span><span class="o">=</span><span class="mf">0</span>
    <span class="k">cdef</span> <span class="kt">size_t</span> <span class="nf">n</span><span class="o">=</span><span class="n">keys</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">rv</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c">#Note this next line: the i-th element in keys is an index</span>
        <span class="c">#corresponding to a location in mcounts.</span>
        <span class="k">if</span> <span class="n">mcounts</span><span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">twoN</span><span class="p">:</span>
            <span class="n">rv</span><span class="o">+=</span><span class="mf">1</span>
    <span class="k">return</span> <span class="n">rv</span>

<span class="k">cdef</span> <span class="kt">vector</span>[<span class="kt">pair</span>[<span class="nf">int</span><span class="p">,</span><span class="kt">int</span>]] <span class="nf">mutations_per_gamete</span><span class="p">(</span><span class="n">const</span> <span class="n">singlepop_t</span> <span class="o">*</span> <span class="n">pop</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">cdef</span> <span class="kt">vector</span>[<span class="kt">pair</span>[<span class="nf">int</span><span class="p">,</span><span class="kt">int</span>]] <span class="nf">rv</span>
    <span class="k">cdef</span> <span class="kt">size_t</span> <span class="nf">i</span> <span class="o">=</span> <span class="mf">0</span>
    <span class="k">cdef</span> <span class="kt">size_t</span> <span class="nf">n</span> <span class="o">=</span> <span class="n">pop</span><span class="o">.</span><span class="n">gametes</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="nf">twoN</span> <span class="o">=</span> <span class="mf">2</span><span class="o">*</span><span class="n">pop</span><span class="o">.</span><span class="n">popsize</span><span class="p">()</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">neutral</span><span class="p">,</span><span class="nf">selected</span>
    <span class="c">#Now, we go through every gamete and:</span>
    <span class="c">#1. Check that it is not extinct</span>
    <span class="c">#2. Go over every mutation in each gamete and make sure that it is not fixed.</span>
    <span class="c">#   We do not need to check that each mutation in each gamete has a nonzero count.</span>
    <span class="c">#   fwdpp ensures that an extant gamete contains extant mutations.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pop</span><span class="o">.</span><span class="n">gametes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mf">0</span><span class="p">:</span> <span class="c">#gamete is not extinct</span>
            <span class="c">#&quot;mutations&quot; = container of indexes to neutral mutations</span>
            <span class="n">neutral</span> <span class="o">=</span> <span class="n">count_mutations</span><span class="p">(</span><span class="n">pop</span><span class="o">.</span><span class="n">gametes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mutations</span><span class="p">,</span><span class="n">pop</span><span class="o">.</span><span class="n">mcounts</span><span class="p">,</span><span class="n">twoN</span><span class="p">)</span>
            <span class="c">#&quot;smutations&quot; = container of indexes to selected mutations</span>
            <span class="n">selected</span> <span class="o">=</span> <span class="n">count_mutations</span><span class="p">(</span><span class="n">pop</span><span class="o">.</span><span class="n">gametes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">smutations</span><span class="p">,</span><span class="n">pop</span><span class="o">.</span><span class="n">mcounts</span><span class="p">,</span><span class="n">twoN</span><span class="p">)</span>
            <span class="n">rv</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="nb">int</span><span class="p">](</span><span class="n">neutral</span><span class="p">,</span><span class="n">selected</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rv</span>
</pre></div>
</div>
<p>Count the number of neutral and deleterious mutations per diploid, and return a list of tuples:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="kt">pair</span>[<span class="nf">int</span><span class="p">,</span><span class="kt">int</span>] <span class="nf">count_mutations_diploid</span><span class="p">(</span><span class="n">const</span> <span class="n">diploid_t</span> <span class="o">&amp;</span> <span class="n">dip</span><span class="p">,</span> <span class="n">const</span> <span class="n">gcont_t</span> <span class="o">&amp;</span> <span class="n">gametes</span><span class="p">,</span> <span class="n">const</span> <span class="n">ucont_t</span> <span class="o">&amp;</span> <span class="n">mcounts</span><span class="p">,</span> <span class="n">const</span> <span class="nb">unsigned</span> <span class="n">twoN</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="c">#Neat: we can re-use the function defined above:</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">neutral</span> <span class="o">=</span> <span class="n">count_mutations</span><span class="p">(</span><span class="n">gametes</span><span class="p">[</span><span class="n">dip</span><span class="o">.</span><span class="n">first</span><span class="p">]</span><span class="o">.</span><span class="n">mutations</span><span class="p">,</span><span class="n">mcounts</span><span class="p">,</span><span class="n">twoN</span><span class="p">)</span>
    <span class="k">cdef</span> <span class="kt">int</span> <span class="nf">selected</span> <span class="o">=</span> <span class="n">count_mutations</span><span class="p">(</span><span class="n">gametes</span><span class="p">[</span><span class="n">dip</span><span class="o">.</span><span class="n">first</span><span class="p">]</span><span class="o">.</span><span class="n">smutations</span><span class="p">,</span><span class="n">mcounts</span><span class="p">,</span><span class="n">twoN</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pair</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="nb">int</span><span class="p">](</span><span class="n">neutral</span><span class="p">,</span><span class="n">selected</span><span class="p">)</span>

<span class="k">cdef</span> <span class="kt">vector</span>[<span class="kt">pair</span>[<span class="nf">int</span><span class="p">,</span><span class="kt">int</span>]] <span class="nf">mutations_per_diploid</span><span class="p">(</span><span class="n">const</span> <span class="n">singlepop_t</span> <span class="o">*</span> <span class="n">pop</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">cdef</span> <span class="kt">vector</span>[<span class="kt">pair</span>[<span class="nf">int</span><span class="p">,</span><span class="kt">int</span>]] <span class="nf">rv</span>
    <span class="k">cdef</span> <span class="kt">size_t</span> <span class="nf">i</span><span class="o">=</span><span class="mf">0</span>
    <span class="k">cdef</span> <span class="kt">size_t</span> <span class="nf">n</span><span class="o">=</span><span class="n">pop</span><span class="o">.</span><span class="n">diploids</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="k">cdef</span> <span class="kt">unsigned</span> <span class="nf">twoN</span> <span class="o">=</span> <span class="mf">2</span><span class="o">*</span><span class="n">n</span>
    <span class="k">cdef</span> <span class="kt">pair</span>[<span class="nf">int</span><span class="p">,</span><span class="kt">int</span>] <span class="nf">temp</span>
    <span class="c">#Now, go through every diploid:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">count_mutations_diploid</span><span class="p">(</span><span class="n">pop</span><span class="o">.</span><span class="n">diploids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">pop</span><span class="o">.</span><span class="n">gametes</span><span class="p">,</span><span class="n">pop</span><span class="o">.</span><span class="n">mcounts</span><span class="p">,</span><span class="n">twoN</span><span class="p">)</span>
        <span class="n">rv</span><span class="o">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rv</span>
</pre></div>
</div>
<p>Time to up the complexity level with the next examples.</p>
<p>Population mean fitness under a multiplicative model.  We will calculate the mean fitness of the population by <em>explicitly calculating the fitness of each diploid</em>.  We will make this calculation under a multiplicative model, <img class="math" src="../_images/math/99e47a33a18c82740f38261e74d5dc131a3578c0.png" alt="w = \prod_i(1+I(i))"/>, where <img class="math" src="../_images/math/701d85dc6e76304f18f145d350b9d3e9356d07ff.png" alt="I(i)"/> is <img class="math" src="../_images/math/cabfc99a50a4ca3310923c0ac2147ca61e82b799.png" alt="sh"/> or <img class="math" src="../_images/math/fbeac31a7d91e00ec9c61e4b8be4b489011e41dc.png" alt="scaling*s"/> for hetero- and homo- zygous mutation positions, respectively.</p>
<p>Some comments:</p>
<ol class="arabic simple">
<li>We will use fwdpp&#8217;s multiplicative_diploid class to do this calculation.</li>
<li>We will use a <a class="reference external" href="http://www.numpy.org">numpy</a> array to store the fitness of every diploid and retuirn the mean of the array as the calculation of mean fitness.</li>
</ol>
<p>Thus, this example shows us how to:</p>
<ol class="arabic simple">
<li>Use more fwdpp</li>
<li>Integrate <a class="reference external" href="http://www.numpy.org">numpy</a> with <a class="reference external" href="http://www.cython.org">Cython</a> code via &#8220;typed array views&#8221;</li>
</ol>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span><span class="p">;</span>
<span class="k">from</span> <span class="nn">cython.view</span> <span class="k">cimport</span> <span class="n">array</span> <span class="k">as</span> <span class="n">cvarray</span>
<span class="k">from</span> <span class="nn">fwdpy.fwdpp</span> <span class="k">cimport</span> <span class="n">multiplicative_diploid</span>

<span class="k">cdef</span> <span class="kt">void</span> <span class="nf">wbar_multiplicative_details</span><span class="p">(</span><span class="n">const</span> <span class="n">singlepop_t</span> <span class="o">*</span> <span class="n">pop</span><span class="p">,</span> <span class="n">double</span><span class="p">[:]</span> <span class="n">w</span><span class="p">,</span> <span class="n">const</span> <span class="n">double</span> <span class="n">scaling</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">cdef</span> <span class="kt">multiplicative_diploid</span> <span class="nf">wfxn</span>
    <span class="k">cdef</span> <span class="kt">size_t</span> <span class="nf">i</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">pop</span><span class="o">.</span><span class="n">diploids</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c">#Here is the trick.  wfxn is a C++ class, but it is also a function!</span>
        <span class="c">#Further, it is a template function.  Cython is not willing to just let</span>
        <span class="c">#the C++ compiler figure out the types here, so we have to explicitly use typecasts,</span>
        <span class="c">#which is what the &lt;foo&gt;bar is: type cast a bar to a foo.  This has NO RUNTIME PENALTY!!!</span>
        <span class="c">#Yes, we also have to cast the scaling parameter, even though it is not a template parameter.</span>
        <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wfxn</span><span class="p">(</span><span class="o">&lt;</span><span class="n">diploid_t</span><span class="o">&gt;</span><span class="n">pop</span><span class="o">.</span><span class="n">diploids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="o">&lt;</span><span class="n">gcont_t</span><span class="o">&gt;</span><span class="n">pop</span><span class="o">.</span><span class="n">gametes</span><span class="p">,</span><span class="o">&lt;</span><span class="n">mcont_t</span><span class="o">&gt;</span><span class="n">pop</span><span class="o">.</span><span class="n">mutations</span><span class="p">,&lt;</span><span class="kt">double</span><span class="p">&gt;</span><span class="n">scaling</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">wbar_mutiplicative</span><span class="p">(</span><span class="n">Spop</span> <span class="n">p</span><span class="p">,</span> <span class="n">const</span> <span class="n">double</span> <span class="n">scaling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is our Python function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c">#Create the numpy array</span>
    <span class="n">w</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">popsize</span><span class="p">(),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="c">#Call our Cython function:</span>
    <span class="n">wbar_multiplicative_details</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">pop</span><span class="o">.</span><span class="n">get</span><span class="p">(),</span><span class="n">w</span><span class="p">[:],</span><span class="n">scaling</span><span class="p">)</span>
    <span class="c">#return mean fitness:</span>
    <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The above function is only useful if you run it on a population using the same &#8220;scaling&#8221; that you used to simulate!!!  Otherwise, the values returned will differ from those used to evolve the populations.</p>
</div>
<p><em>fwdpy</em> also provides an interface to the additive fitness calculation object from <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a>.  It has the same interface:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="nn">fwdpy.fwdpp</span> <span class="k">cimport</span> <span class="n">additive_diploid</span>
</pre></div>
</div>
<p>Some comments are needed:</p>
<ol class="arabic simple">
<li>multiplicative_diploid and additive_diploid return non-negative doubles representing fitness.</li>
<li>Thus, they are not suitable as object for calculating <em>phenotypes</em>.</li>
</ol>
<p>We will return to phenotypes vs fitness later on, in the section on plugins providing custom fitness models.</p>
</div>
</div>
</div>
</div>
<div class="section" id="additional-material">
<h2>Additional material<a class="headerlink" href="#additional-material" title="Permalink to this headline">¶</a></h2>
<p>Between <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a> and <em>fwdpy</em>, a lot of stuff is already implemented.</p>
<p>The following pxd files make various C++ functions available to plugins:</p>
<ul class="simple">
<li>fwdpy/fwdpp.pxd exposes a lot of <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a>.  Those functions are documented in that library&#8217;s <a class="reference external" href="http://molpopgen.github.io/fwdpp/doc/html/index.html">manual</a>.</li>
<li>fwdpy/fwdpy.pxd defines a lot of the <a class="reference external" href="http://www.cython.org">Cython</a> extension classes and exposes types like singlepop_t, etc. This is the &#8220;main&#8221; pxd file for the package.</li>
<li>fwdpy/fitness.pxd is the basis for fitness models and contains many cdef functions to aid writing custom fitness functions.</li>
</ul>
<p>These pxd file will be viewed most easily at <em>fwdpy</em>&#8216;s <a class="reference external" href="http://github.com/molpopgen/fwdpy">repo</a>.</p>
<p>The Git repo <a class="reference external" href="http://github.com/molpopgen/fwdpy_plugins">fwdpy_plugins</a> contains working plugin examples, including all of the above &#8220;recipes&#8221;.</p>
</div>
</div>
<div class="section" id="implementing-custom-fitness-functions">
<h1>Implementing custom fitness functions<a class="headerlink" href="#implementing-custom-fitness-functions" title="Permalink to this headline">¶</a></h1>
<p>This section covers how to write your own &#8220;fitness&#8221; functions.  First, we cover important concepts.  Then, we describe the set of functions that <em>fwdpy</em> provides to help implementing custom fitness models.  Then, we work through some examples.</p>
<p>Please note that I&#8217;m using the term &#8220;fitness&#8221; here somewhat loosely, as sometimes such a function may be used to calculate a genetic value for a diploid, as in the case of simulations of quantitative traits.</p>
<div class="section" id="concepts">
<h2>Concepts<a class="headerlink" href="#concepts" title="Permalink to this headline">¶</a></h2>
<div class="section" id="types-of-fitness-models">
<h3>Types of fitness models<a class="headerlink" href="#types-of-fitness-models" title="Permalink to this headline">¶</a></h3>
<p>Fundamentally, there are two ways that these types of functions work:</p>
<ol class="arabic simple">
<li>Fitness depends on whether or not a mutation is found in heterozyzous (Aa) or homozygous (aa) state in a diploid.  We&#8217;ll call this a &#8220;site-based&#8221; fitness model.</li>
<li>Fitness depends on properties of separate haplotypes, which are then combined into a single value for fitness.  We&#8217;ll call these &#8220;haplotype-based&#8221; fitness models.</li>
</ol>
</div>
<div class="section" id="types-of-fitness-model-objects">
<h3>Types of fitness model <em>objects</em><a class="headerlink" href="#types-of-fitness-model-objects" title="Permalink to this headline">¶</a></h3>
<p>Further, if all we need to know about a diploid in order to calculate its fitness is what gametes (and therefore what mutations) a diploid contains, then our fitness model requires <em>no extra data</em>.  Such a situation can be represented via a &#8220;stateless&#8221; object, one requiring no extra information about the population or its history.</p>
<p><em>fwdpy</em> supports stateless fitness objects.</p>
</div>
<div class="section" id="the-relevant-cython-extension-types">
<h3>The relevant Cython extension types<a class="headerlink" href="#the-relevant-cython-extension-types" title="Permalink to this headline">¶</a></h3>
<p>These are defined in the source file fwdpy/fitness.pxd.  The types are:</p>
<ul class="simple">
<li><a class="reference internal" href="../index.html#fwdpy.fitness.SpopFitness" title="fwdpy.fitness.SpopFitness"><code class="xref py py-class docutils literal"><span class="pre">fwdpy.fitness.SpopFitness</span></code></a></li>
<li><a class="reference internal" href="../index.html#fwdpy.fitness.MlocusFitness" title="fwdpy.fitness.MlocusFitness"><code class="xref py py-class docutils literal"><span class="pre">fwdpy.fitness.MlocusFitness</span></code></a></li>
</ul>
<p>Custom types will be extensions of these base types. For example:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">cdef</span> <span class="k">class</span> <span class="nf">MyFitness</span><span class="p">(</span><span class="n">SpopFitness</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div>
<div class="section" id="helper-functions">
<h3>Helper functions<a class="headerlink" href="#helper-functions" title="Permalink to this headline">¶</a></h3>
<p><em>fwdpy</em> provides several &#8220;helper&#8221; functions to simplify writing custom fitness functions.  These are defined in fwdpy/fitness.pxd, and that file is heavily commented.</p>
<p>In general, you&#8217;ll probably just want to import everything from the fitness module:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="k">from</span> <span class="nn">fwdpy.fitness</span> <span class="k">cimport</span> <span class="o">*</span>
</pre></div>
</div>
<p>To see how these functions are used, take a look at fwdpy/fitness.pyx, which is where the built-in fitness models are implemented.  The built-in models are implemented using the machinery for implementing custom fitness models.</p>
</div>
<div class="section" id="stateless-fitness-objects">
<h3>Stateless fitness objects<a class="headerlink" href="#stateless-fitness-objects" title="Permalink to this headline">¶</a></h3>
<p>In C++, a fitness function for a single-deme simulation returns a float64 and takes a diploid_t, gcont_t, and mcont_t as arguments:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">//This is the function pointer type representing a valid fitness function</span>
<span class="kt">double</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="n">diploid_t</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">gcont_t</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">mcont_t</span> <span class="o">&amp;</span><span class="p">)</span>
</pre></div>
</div>
<p>Often, it is tedious to write such a full-blown fitness function.  Also, <a class="reference external" href="http://molpopgen.github.io/fwdpp/">fwdpp</a> already has fast routines for &#8220;site-based&#8221; models.  For this reason, <em>fwdpy</em> allows you to provide three simpler functions:</p>
<ol class="arabic simple">
<li>A function that updates fitness when a mutation is Aa.</li>
<li>A function that updates fitness when a mutation is aa.</li>
<li>A function that returns the final fitness value.</li>
</ol>
<p>The signature of the first two are:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">double</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">popgenmut</span> <span class="o">&amp;</span><span class="p">)</span>
</pre></div>
</div>
<p>And the final function type is:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">double</span><span class="p">)</span>
</pre></div>
</div>
<p>For &#8220;haplotype-based&#8221; fitness schemes, you need two functions:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="c1">//Take a haplotype, process it, and return some value</span>
<span class="kt">double</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="k">const</span> <span class="n">gamete_t</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">mcont_t</span> <span class="o">&amp;</span><span class="p">)</span>
<span class="c1">//Take the two haplotype values, and return a final value:</span>
<span class="kt">double</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">double</span><span class="p">,</span><span class="kt">double</span><span class="p">)</span>
</pre></div>
</div>
<p>Stateless models are implemented in terms of the C++ class singlepop_fitness, exposed to <a class="reference external" href="http://www.cython.org">Cython</a> in fwdpy/fitness.pxd.</p>
<p>The file stateless_fitness_models.pyx that comes with <a class="reference external" href="http://github.com/molpopgen/fwdpy_plugins">fwdpy_plugins</a> shows working examples of implementing the standard additive fitness model several different ways. The contents of that file are:</p>
<div class="highlight-cython"><div class="highlight"><pre><span></span><span class="c">#Example of plugins implementing &quot;stateless&quot; fitness models</span>
<span class="c">#We will implement the standard additive model several different</span>
<span class="c">#ways, plus one haplotype-based model</span>

<span class="c">#The additive model of fitness is 1+sum(g_i), where g_i is sh</span>
<span class="c">#for Aa genotypes and 2s for aa genotypes.</span>

<span class="c">#The additive model of a trait value would simply be sum(g_i),</span>
<span class="c">#and therefore the &quot;return fitness&quot; function matters:</span>

<span class="k">from</span> <span class="nn">fwdpy.fitness</span> <span class="k">cimport</span> <span class="o">*</span>
<span class="k">from</span> <span class="nn">libcpp.memory</span> <span class="k">cimport</span> <span class="n">unique_ptr</span>

<span class="k">cdef</span> <span class="kr">extern</span> <span class="k">from</span> <span class="s">&quot;&lt;algorithm&gt;&quot;</span> <span class="n">namespace</span> <span class="s">&quot;std&quot;</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="n">T</span> <span class="nb">max</span><span class="p">[</span><span class="n">T</span><span class="p">](</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>

<span class="c">#First, we&#39;ll implement the additive model</span>
<span class="c">#by writing functions that process Aa and aa</span>
<span class="c">#genotypes at each site and then return a final fitness</span>
<span class="c">#value</span>

<span class="c">#This function is how fitness is updated for heterozygous (Aa)</span>
<span class="c">#genotypes</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">additiveAa</span><span class="p">(</span><span class="n">double</span> <span class="o">&amp;</span> <span class="n">w</span><span class="p">,</span> <span class="n">const</span> <span class="n">popgenmut</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">)[</span><span class="mf">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">h</span><span class="o">*</span><span class="n">m</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>

<span class="c">#This function is how fitness is updated for a homozygous genotype</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">additiveaa</span><span class="p">(</span><span class="n">double</span> <span class="o">&amp;</span> <span class="n">w</span><span class="p">,</span> <span class="n">const</span> <span class="n">popgenmut</span> <span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">)[</span><span class="mf">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">m</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>

<span class="c">#For additive models, we can simply return 1+w.</span>
<span class="c">#If we wanted additivity for a quantitative trait,</span>
<span class="c">#then this function would return w, to</span>
<span class="c">#center the value at an average trait value of 0.</span>
<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">double</span> <span class="nf">return_fitness</span><span class="p">(</span><span class="n">double</span> <span class="n">w</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">[</span><span class="n">double</span><span class="p">](</span><span class="mf">1.0</span><span class="o">+</span><span class="n">w</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>

<span class="c">#Now, we construct our custom fitness class,</span>
<span class="c">#which can be used as a fitness model in a simulation</span>
<span class="k">cdef</span> <span class="k">class</span> <span class="nf">CustomAdditive1</span><span class="p">(</span><span class="n">SpopFitness</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__cinit__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wfxn</span> <span class="o">=</span> <span class="n">unique_ptr</span><span class="p">[</span><span class="n">singlepop_fitness</span><span class="p">](</span><span class="n">new</span> <span class="n">singlepop_fitness</span><span class="p">(</span><span class="n">additiveAa</span><span class="p">,</span>     <span class="c">#Pass in the &quot;Aa updating fxn&quot;</span>
                                                                        <span class="n">additiveaa</span><span class="p">,</span>     <span class="c">#The &quot;aa updating fxn&quot;</span>
                                                                        <span class="n">return_fitness</span><span class="p">,</span> <span class="c">#The fxn to return the final fitness value</span>
                                                                        <span class="mf">0.0</span><span class="p">))</span>           <span class="c">#The initial value for fitness</span>

<span class="c">#See fwdpy/fitness.pxd and fwdpy/fitness.pyx for how additive &amp; multiplicative fitness models are implemented in fwdpy</span>

<span class="c">#Now, let&#39;s implement it as a more complex function representing the full signature of a fitness function:</span>

<span class="c">#import fwdpp&#39;s function object for calculating additve effects over sites:</span>
<span class="k">from</span> <span class="nn">fwdpy.fwdpp</span> <span class="k">cimport</span> <span class="n">additive_diploid</span>

<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">double</span> <span class="nf">additive_fitness_fxn1</span><span class="p">(</span><span class="n">const</span> <span class="n">diploid_t</span> <span class="o">&amp;</span> <span class="n">dip</span><span class="p">,</span> <span class="n">const</span> <span class="n">gcont_t</span> <span class="o">&amp;</span> <span class="n">gametes</span><span class="p">,</span> <span class="n">const</span> <span class="n">mcont_t</span> <span class="o">&amp;</span> <span class="n">mutations</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="c">#Create an additive_diploid object:</span>
    <span class="k">cdef</span> <span class="kt">additive_diploid</span> <span class="nf">a</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span><span class="n">gametes</span><span class="p">,</span><span class="n">mutations</span><span class="p">,</span><span class="mf">2.0</span><span class="p">)</span>

<span class="k">cdef</span> <span class="kr">inline</span> <span class="kt">double</span> <span class="nf">additive_fitness_fxn2</span><span class="p">(</span><span class="n">const</span> <span class="n">diploid_t</span> <span class="o">&amp;</span> <span class="n">dip</span><span class="p">,</span> <span class="n">const</span> <span class="n">gcont_t</span> <span class="o">&amp;</span> <span class="n">gametes</span><span class="p">,</span> <span class="n">const</span> <span class="n">mcont_t</span> <span class="o">&amp;</span> <span class="n">mutations</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="c">#Use the wrapper around fwdpp&#39;s site_dependent fitness</span>
    <span class="c">#defined in fwdpy/fitness.pxd:</span>
    <span class="k">cdef</span> <span class="kt">site_dependent_fitness_wrapper</span> <span class="nf">wrapper</span>
    <span class="c">#call it like a function, passing our cdef functions from above:</span>
    <span class="k">return</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span><span class="n">gametes</span><span class="p">,</span><span class="n">mutations</span><span class="p">,</span><span class="n">additiveaa</span><span class="p">,</span><span class="n">additiveAa</span><span class="p">,</span><span class="n">return_fitness</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span> <span class="c">#Note that additiveaa is passed in b4 additiveAa.  Yes, this is inconsistent w.r.to above, but it matches the fwdpp interface for site_depdendent_fitness.</span>

<span class="c">#Now we can define two new additive fitness models:</span>

<span class="k">cdef</span> <span class="k">class</span> <span class="nf">CustomAdditive2</span><span class="p">(</span><span class="n">SpopFitness</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__cinit__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wfxn</span> <span class="o">=</span> <span class="n">unique_ptr</span><span class="p">[</span><span class="n">singlepop_fitness</span><span class="p">](</span><span class="n">new</span> <span class="n">singlepop_fitness</span><span class="p">(</span><span class="n">additive_fitness_fxn1</span><span class="p">))</span>

<span class="k">cdef</span> <span class="k">class</span> <span class="nf">CustomAdditive3</span><span class="p">(</span><span class="n">SpopFitness</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__cinit__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wfxn</span> <span class="o">=</span> <span class="n">unique_ptr</span><span class="p">[</span><span class="n">singlepop_fitness</span><span class="p">](</span><span class="n">new</span> <span class="n">singlepop_fitness</span><span class="p">(</span><span class="n">additive_fitness_fxn2</span><span class="p">))</span>

<span class="c">#Finally, let&#39;s define additive fitness as the sum of the sums of selection coefficients on each</span>
<span class="c">#hapltype.  Note that this explicitly assumes h=1!!!!</span>

<span class="c">#We will use functions from fwdpy/fitness.pxd in order to get the job done:</span>

<span class="k">cdef</span> <span class="kt">double</span> <span class="nf">add_hap_effects</span><span class="p">(</span><span class="n">double</span> <span class="n">a</span><span class="p">,</span><span class="n">double</span> <span class="n">b</span><span class="p">)</span> <span class="k">nogil</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">[</span><span class="n">double</span><span class="p">](</span><span class="mf">1.0</span><span class="o">+</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span>

<span class="k">cdef</span> <span class="k">class</span> <span class="nf">CustomAdditive4</span><span class="p">(</span><span class="n">SpopFitness</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__cinit__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wfxn</span><span class="o">=</span><span class="n">unique_ptr</span><span class="p">[</span><span class="n">singlepop_fitness</span><span class="p">](</span><span class="n">new</span> <span class="n">singlepop_fitness</span><span class="p">(</span><span class="n">sum_haplotype_effects</span><span class="p">,</span><span class="n">add_hap_effects</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>More examples of stateless custom fitness functions are found in the repo <a class="reference external" href="http://github.com/molpopgen/fwdpy_plugins">fwdpy_plugins</a>.  The examples are kept in a different source repo for a few reasons.  First, it is easiest to have a repo that we can test instead of static documentation that may drift from reality.  Second, compiling plugins required that <em>fwdpy</em> be installed and that the plugin code is not in the <em>fwdpy</em> repo.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Overview</a><ul>
<li><a class="reference internal" href="#glossary">Glossary</a></li>
<li><a class="reference internal" href="#file-extensions">File extensions</a></li>
<li><a class="reference internal" href="#compiling-a-cython-only-plugin">Compiling a Cython-only plugin</a></li>
<li><a class="reference internal" href="#compiling-a-plugin-that-contains-extra-c-code">Compiling a plugin that contains extra C++ code</a></li>
<li><a class="reference internal" href="#the-c-types-used-in-fwdpy">The C++ types used in <em>fwdpy</em></a><ul>
<li><a class="reference internal" href="#mutation-types">Mutation types</a><ul>
<li><a class="reference internal" href="#popgenmut">popgenmut</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mutation-containers-and-mutation-counts">Mutation containers and mutation counts.</a></li>
<li><a class="reference internal" href="#gametes-and-gamete-containers">Gametes and gamete containers</a></li>
<li><a class="reference internal" href="#diploids">Diploids</a></li>
<li><a class="reference internal" href="#population-types">Population types</a><ul>
<li><a class="reference internal" href="#singlepop-t">singlepop_t</a><ul>
<li><a class="reference internal" href="#singlepop-t-and-python">singlepop_t and Python</a></li>
<li><a class="reference internal" href="#recipes">Recipes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#additional-material">Additional material</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-custom-fitness-functions">Implementing custom fitness functions</a><ul>
<li><a class="reference internal" href="#concepts">Concepts</a><ul>
<li><a class="reference internal" href="#types-of-fitness-models">Types of fitness models</a></li>
<li><a class="reference internal" href="#types-of-fitness-model-objects">Types of fitness model <em>objects</em></a></li>
<li><a class="reference internal" href="#the-relevant-cython-extension-types">The relevant Cython extension types</a></li>
<li><a class="reference internal" href="#helper-functions">Helper functions</a></li>
<li><a class="reference internal" href="#stateless-fitness-objects">Stateless fitness objects</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="vareg.html" title="previous chapter">Estimating cumulative <img class="math" src="../_images/math/aeb4b64115fe29aa42095dc692f5b5fb43dac071.png" alt="V(A)"/> in simulations of quantitative traits.</a></li>
      <li>Next: <a href="code.html" title="next chapter">Source code organization</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/pages/plugins.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, KRT.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="../_sources/pages/plugins.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>